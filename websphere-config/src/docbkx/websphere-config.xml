<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
    <articleinfo>
        <title>Understanding the WebSphere config service</title>
        <author><firstname>Andreas</firstname><surname>Veithen</surname></author>
        <releaseinfo>Revision <?eval ${project.version}?></releaseinfo>
    </articleinfo>
    <section>
        <title>Repository structure</title>
        <para>
            At a low level, the WebSphere configuration repository is a collection of folders and documents.
            Although these resources are persisted one-to-one as directories and files under the <filename>config</filename>
            directory in the WebSphere profile, the <firstterm>configuration repository service</firstterm> in WebSphere is more than a simple file
            access service. It allows a client (such as <command>wsadmin</command>) to prepare a set of changes
            in a so called <firstterm>workspace</firstterm><footnote><para>Workspaces are stored in the <filename>wstemp</filename> directory
            in the WebSphere profile.</para></footnote> and to save these changes at once (or to discard the changes
            if something goes wrong). The repository service detects conflicts to prevent clients from attempting
            to modify the same documents concurrently. It also tracks changes so that node agents can incrementally
            replicate the master configuration repository from the deployment manager to individual nodes.
        </para>
        <para>
            The configuration repository is used by WebSphere for various things. E.g. application binaries are stored
            there. However, most of the documents in the repository contain <firstterm>configuration objects</firstterm>.
            To manage this configuration data, WebSphere adds another layer on top of the configuration repository service:
            the <firstterm>config service</firstterm>. The config service uses the following concepts:
        </para>
        <variablelist>
            <varlistentry>
                <term>Repository context</term>
                <listitem>
                    <para>
                        A repository context is a structure that can contain documents and nested repository contexts.
                        Each repository context has a type and a name. Contexts are mapped to two-level folder structures,
                        where the first level identifies the context type and the second level identifies the context name.
                        <xref linkend="fig-contexts-sample"/> shows an example of a repository structure representing
                        two contexts of type <literal>servers</literal>, one named <literal>nodeagent</literal> and
                        one named <literal>server1</literal>.
                    </para>
                    <figure id="fig-contexts-sample">
                        <title>Repository context example</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="contexts.png" format="PNG"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                    <note>
                        <para>
                            TODO: not entirely correct; there are also contexts that have no name and that are mapped to
                            a one-level folder structure.
                        </para>
                    </note>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Document</term>
                <listitem>
                    <para>
                        At the repository level, a document can have any content. The config service on the other hand
                        has a narrower definition of a document, namely an XML file that contains a set of configuration
                        objects in serialized form.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Configuration object</term>
                <listitem>
                    <para>
                        Configuration objects are described using the
                        <ulink url="http://www.eclipse.org/modeling/emf/">Eclipse Modeling Framework</ulink>. 
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section id="metadata">
        <title>Metadata</title>
        <para>
            To manage the configuration data, the config service needs metadata that describes the
            supported types of contexts, documents and configuration objects, as well as their relationships.
            This metadata comes from two sources that we will describe in this section.
        </para>
        <para>
            As noted earlier, configuration objects are defined using EMF.
            In EMF, classes and their relationships are described using <firstterm>Ecore models</firstterm>.
            Ecore models are conceptually similar to (but simpler than) UML models, and they
            can be used to generate Java code. The generated code not only contains the Java classes
            corresponding to the classes defined in the Ecore model, but also code that allows to
            introspect the model at runtime. This code is contained in implementations of the
            <classname>org.eclipse.emf.ecore.EPackage</classname> interface that are registered
            in the EMF package registry (<literal>EPackage.Registry.INSTANCE</literal>).
            The config service uses this EMF metadata to discover configuration object types,
            their attributes and relationships which each other.
        </para>
        <para>
            Starting with version 6.1, the WebSphere runtime has a modular design based on
            the Eclipse platform. It is split into a set of plug-ins, and each of these plug-ins
            can contribute EMF packages to the configuration model.
            In EMF, the standard mechanism to discover packages in the deployed plug-ins and to populate
            the package registry uses the <literal>org.eclipse.emf.ecore.generated_package</literal>
            extension point.
            However, WebSphere uses its own extension point for this, namely
            <literal>com.ibm.wsspi.extension.server-model-init</literal>.
        </para>
        <para>
            WebSphere uses EMF as a facility to discover configuration object types and also
            to store graphs of configuration objects in XML documents. However, EMF doesn't allow
            to describe the overall structure of the repository, e.g. which document is used to
            store which type of configuration object, and what are the documents expected in a
            given repository context.
        </para>
        <para>
            That kind of metadata is provided by a set of XML documents stored in the
            <filename>.repository</filename> folder in the repository itself.
            All the files in that folder have the same structure, as shown in
            <xref linkend="fig-metadata-schema"/>.
        </para>
        <figure id="fig-metadata-schema">
            <title>Structure of the metadata files in the <filename>.repository</filename> folder</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="metadata-schema.png" format="PNG"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            One can see that these files define the hierarchy of repository contexts as well as the
            documents that can exist in each context. The <literal>root-refobject-type</literal> elements
            also establish links between document types and the types of configuration objects they contain.
        </para>
        <para>
            Files in the <filename>.repository</filename> folder are parsed by a class called
            <classname>com.ibm.ws.sm.workspace.metadata.impl.MetaDataParser</classname>.
            Metadata coming from different files is simply merged together by that parser. This means e.g. that
            a repository context is not necessarily completely defined in a single file; the definition
            may be scattered over multiple files.
            The reason for this is obviously to allow a product extension to modify an existing context
            definition by simply adding a file to the <filename>.repository</filename> folder.
        </para>
        <para>
            At runtime, the metadata is modelled as shown in <xref linkend="fig-repository-metadata"/>.
            Note that <classname>EClass</classname> represents the EMF metadata for a given
            configuration object type.
        </para>
        <figure id="fig-repository-metadata">
            <title>Repository metadata</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="repository-metadata.png" format="PNG"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>
    <section>
        <title>Configuration object serialization; root and inner configuration objects</title>
        <para>
            As mentioned earlier, WebSphere uses EMF not only to describe configuration objects,
            but also to serialize them to XML. This XML data is then stored as documents in the repository.
            Actually, the format used is XMI (XML Metadata Interchange). It allows to serialize
            EMF model instances to XML in a standard way without additional metadata (i.e. without the need to
            explicitly define the mapping to XML).
        </para>
        <para>
            EMF explicitly supports the notion of <firstterm>containment</firstterm>.
            E.g. the <classname>ServerCluster</classname> class has an attribute <varname>members</varname>
            which is a reference of type <classname>ClusterMember</classname> with multiplicity 0&hellip;*.
            This reference is modelled as a containment relation.
            In XMI, contained objects are serialized as child elements of the XML element representing
            the containing object, as shown in the following sample:
        </para>
        <programlisting><?db-font-size 70%?><![CDATA[<topology.cluster:ServerCluster xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI"
    xmlns:topology.cluster="http://www.ibm.com/websphere/appserver/schemas/5.0/topology.cluster.xmi"
    xmi:id="ServerCluster_1362990710886"
    name="cluster0" preferLocal="true" nodeGroupName="DefaultNodeGroup">
  <members xmi:id="ClusterMember_1362990716560" memberName="server1" weight="2"
      uniqueId="1362990714239" nodeName="ulx00003"/>
  <members xmi:id="ClusterMember_1362990717935" memberName="server2" weight="2"
      uniqueId="1362990716833" nodeName="ulx00004"/>
</topology.cluster:ServerCluster>]]></programlisting>
        <para>
            Note that an XMI document can have one or more root objects. In the latter case,
            the serialized objects are wrapped in an <literal>xmi:XMI</literal> element.
            E.g. a <filename>resources.xml</filename> document contains a collections a collection
            of <classname>J2EEResourceProvider</classname> objects.
        </para>
        <para>
            The existence of containment relations allows to distinguish between to categories
            of configuration objects:
        </para>
        <variablelist>
            <varlistentry>
                <term>Root configuration object</term>
                <listitem>
                    <para>
                        A configuration object that is not contained in another configuration object and
                        that appears at the top level of an XMI document.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Inner configuration object</term>
                <listitem>
                    <para>
                        A configuration ojbect that is contained in another configuration object
                        (which may be a root or an inner configuration object).
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In principle, the same configuration object type could be used both for root configuration objects
            and for inner configuration objects (depending on the part of the configuration where it is used).
            However this possibility is not actually used, which means that the distinction between
            root and inner not only applies to configuration objects, but also extends to configuration object types.
            E.g. <classname>ServerCluster</classname> is a root configuration object type, and
            <classname>ClusterMember</classname> is an inner configuration object type.
        </para>
        <note>
            <para>
                Not correct; see <filename>pmi-config.xml</filename>.
            </para>
        </note>
    </section>
    <section>
        <title>Configuration IDs</title>
        <para>
            A configuration object is uniquely identified by an identifier with the following structure:
        </para>
        <screen><replaceable>name</replaceable>(<replaceable>context</replaceable>|<replaceable>file</replaceable>#<replaceable>id</replaceable>)</screen>
        <para>
            <replaceable>context</replaceable> identifies the repository context and is equal to the relative path to
            the corresponding folder in the repository, <replaceable>file</replaceable> identifies the document in that folder and
            <replaceable>id</replaceable> identifies the configuration object inside that document.
            <replaceable>name</replaceable> is not a mandatory part of the configuration ID. It is returned by WebSphere
            for objects that have a <varname>name</varname> attribute and its only purpose is to improve human readability.
            For configuration IDs passed to WebSphere, the <replaceable>name</replaceable> is ignored.
        </para>
        <para>
            Example:
        </para>
        <screen>lx03(cells/test/nodes/lx03|node.xml#Node_1)</screen>
        <para>
            Obviously the format of the configuration ID is chosen to allow WebSphere to load a configuration object
            quickly without scanning the entire repository.
        </para>
    </section>
    <section>
        <title>Parent-child relationships</title>
        <section id="parent-child-definition">
            <title>How parent-child relations are defined</title>
            <para>
                Configuration objects are linked by parent-child relations. They are defined in two different ways:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        By containment relations in the EMF models (cf. previous section).
                        E.g. a <classname>ClusterMember</classname> is a child of a <classname>ServerCluster</classname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <xref linkend="fig-repository-metadata"/> shows that for every repository context,
                        there is a single root document. E.g. for a <filename>cells/*/nodes/*/servers/*</filename> context,
                        the root document is <filename>server.xml</filename>. Each of these root documents is expected
                        to contain a single root configuration object. E.g. for <filename>server.xml</filename>
                        these are <classname>Server</classname> objects.
                    </para>
                    <para>
                        The root configuration object in the root document of a given context is considered the
                        parent of the following set of configuration objects:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The root configuration objects in all documents in that context
                                other than the root document.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The root configuration objects in all root documents of all child contexts.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        E.g. a <classname>JDBCProvider</classname> object stored in the <filename>resources.xml</filename>
                        document in a <filename>cells/*/nodes/*/servers/*</filename> context is a child of the
                        <classname>Server</classname> object in the <filename>server.xml</filename> document in that context.
                        That <classname>Server</classname> object itself is a child of the <classname>Node</classname>
                        object stored in the <filename>node.xml</filename> document of the parent context.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                It is easy to see that with these definitions, a given configuration object can have at most one parent.
                Also note that the root context (corresponding to the repository root and not to be confused with
                the <filename>cells/*</filename> context) doesn't define a root document type. This means that the
                repository will contain multiple configuration objects that have no parents. This includes the
                <classname>Cell</classname> object (corresponding to the unique <filename>cells/*</filename> context)
                as well as one or more <classname>Policy</classname> objects (corresponding to the
                <filename>waspolicies/*</filename> contexts).
            </para>
            <note>
                <para>
                    We have seen that documents are simply containers for configuration objects and that WebSphere defines
                    parent-child relations that connect every configuration object to a limited set of
                    configuration objects without parents (of which only a single one is usually relevent, namely
                    the <classname>Cell</classname> object). This means that it is a good approximation to simply view
                    the WebSphere configuration data as a tree of configuration objects, and that in practice one rarely has
                    to deal directly with the concept of repository context and document.
                </para>
            </note>
            <para>
                For a given configuration object type, the metadata described in <xref linkend="metadata"/>
                determines which types of configuration objects are allowed as parents and as children.
                This information can be queried using the <methodname>getRelationshipsMetaInfo</methodname>
                operation on the <classname>ConfigService</classname> MBean or the <methodname>parents</methodname> and
                <methodname>contents</methodname> methods of the <classname>AdminConfig</classname> object in <command>wsadmin</command>.
                E.g. for the <classname>CacheProvider</classname> type, the allowed parent types are
                <classname>Cell</classname>, <classname>Node</classname>, <classname>Server</classname>
                and <classname>ServerCluster</classname>.
            </para>
        </section>
        <section id="navigating-parent-child">
            <title>Navigating parent-child relations</title>
            <para>
                The <classname>AdminConfig</classname> object in <command>wsadmin</command> has several methods that
                allow to navigate parent-child relations. For navigation from parents to children (or ancestors to descendants), these are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>showAttribute</methodname></term>
                    <listitem>
                        <para>
                            This method can be used to navigate from a parent object to a child object if the
                            parent-child relation is derived from a containment relation in EMF, i.e. if the child object
                            is part of the same document as the parent object. This type of relation is always defined using
                            an attribute on the parent object, and in this case the <methodname>showAttribute</methodname>
                            method returns a list of configuration IDs for the child objects.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>getid</methodname></term>
                    <term><methodname>list</methodname></term>
                    <listitem>
                        <para>
                            These methods can be used to navigate any type of parent-child relation.
                            Note that <methodname>list</methodname> actually performs a search in a subtree, i.e.
                            it allows to navigate directly from an ancestor to a descendant without following
                            the intermediate parent-child relations.
                            More on this in <xref linkend="getid-vs-list"/>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                TODO: navigating from child to parent?
            </para>
        </section>
    </section>
    <section id="getid-vs-list">
        <title><methodname>getid</methodname> vs. <methodname>list</methodname></title>
        <para>
            As mentioned in <xref linkend="navigating-parent-child"/>, the <methodname>getid</methodname> 
            and <methodname>list</methodname> methods of the <classname>AdminConfig</classname> object
            in <command>wsadmin</command> both allow to navigate parent-child relations.
            They differ not only in usage and features, but also in the way they locate configuration objects.
        </para>
        <section>
            <title><methodname>getid</methodname></title>
            <para>
                <methodname>getid</methodname> locates configuration objects matching a given <firstterm>containment path</firstterm>.
                A containment path is a sequence of type/name pairs, the name part being optional.
                That sequence is passed to <methodname>getid</methodname> as a single string with the following syntax:
            </para>
            <screen>/Node:lx03/Server:server1/JDBCProvider:/</screen>
            <para>
                Note that the corresponding operation on the <classname>ConfigService</classname> MBean
                uses a different syntax:
            </para>
            <screen>Node=lx03:Server=server1:JDBCProvider=</screen>
            <para>
                The first step in the containment path is evaluated using a subtree search starting from the
                root repository context, using the same approach as the <methodname>list</methodname> method (see below).
                The result of the evaluation of the first step is a set of configuration objects.
                Subsequent steps are evaluated iteratively, and each time a new set of configuration objects
                is constructed by locating the matching child objects of the configuration objects
                returned by the previous step.
                The result of the <methodname>getid</methodname> is the set of configuration objects (actually
                their configuration IDs) returned by the last step.
            </para>
            <para>
                Child objects are located using the definitions described in <xref linkend="parent-child-definition"/>.
                This process always needs to consider parent-child relations defined by containment relations in EMF.
                Note that such relations never cross document boundaries.
                For a configuration object that is the root configuration object in the root document of a
                repository context, additional parent-child relations need to be considered, and the situation
                is more complex because these relations cross document (and sometimes repository context) boundaries.
                Since the type of child configuration objects is known in advance, <methodname>getid</methodname>
                can use the metadata described in <xref linkend="fig-repository-metadata"/> to narrow down the
                document(s) (and contexts) that need to be examined.
            </para>
        </section>
        <section id="adminconfig-list">
            <title><methodname>list</methodname></title>
            <para>
                <methodname>list</methodname> performs a subtree search for configuration objects of a given type.
                The one-argument variant of the <methodname>list</methodname> method always starts from the root repository context.
                The two-argument variant allows to specify the object from where to start the subtree search.
                If the scope object is an inner configuration object or a root configuration object that doesn't
                correspond to a root document, then by definition, the search is limited to a single document.
                On the other hand, if no scope object is given or if the scope object is the root configuration object
                of a root document, then the search scope corresponds to an entire repository context (including all
                descendants). This may cover a very large number of documents. To avoid scanning all these documents,
                the <methodname>list</methodname> method uses a specific algorithm to address that
                case<footnote><para>To see this in action, use the following trace spec:</para>
                <screen>com.ibm.ws.management.configservice.*=all:com.ibm.ws.sm.workspace.impl.*=all</screen>
                <para>This will show the calls to the <methodname>com.ibm.ws.sm.workspace.impl.RepositoryContextImpl#getAllList</methodname>
                method which returns the list of all documents in a given context.
                That call is followed by a call to
                <literal>com.ibm.ws.management.configservice.WorkspaceHelper#getDocAccessor</literal>
                for each document with a matching name.</para></footnote>:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Determine the document types that may contain objects of the type being searched for.
                        If the configuration object type is a root configuration object, then
                        the metadata shown in <xref linkend="fig-repository-metadata"/> allows to get this
                        information easily. If the object type being searched for is an inner configuration object, then
                        the EMF metadata is used to determine the corresponding root configuration object type first.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Recursively search the repository context for candidate documents. This simply uses the
                        fact that all documents of a given type have the same file name.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Search each document found for configuration objects of the expected type.
                    </para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Metadata inconsistencies</title>
            <para>
                WebSphere doesn't validate that the repository structure conforms to the metadata described in
                <xref linkend="fig-repository-metadata"/>. This implies that it is possible to see documents in
                the repository that are not expected to be there if one refers to the repository metadata
                in <filename>.repository</filename>.
            </para>
            <para>
                E.g. <filename>.repository/metadata_cei.xml</filename> specifies
                that a <filename>resources-cei.xml</filename> file with root object type
                <classname>EventInfrastructureProvider</classname> can appear in repository contexts of type
                <literal>cells</literal>, <literal>nodes</literal> and <literal>servers</literal>,
                but not <literal>clusters</literal>. Nevertheless, when a cluster is created, WebSphere also
                creates a <filename>resources-cei.xml</filename> document in the corresponding context.
            </para>
            <para>
                Such inconsistencies have interesting consequences because <methodname>getid</methodname> and
                <methodname>list</methodname> use fairly different algorithms to locate configuration objects
                and these algorithms are affected differently by inconsistencies with respect to the repository metadata:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <methodname>getid</methodname> with containment path
                        <literal>/ServerCluster:/EventInfrastructureProvider:/</literal> will return an empty list, even
                        if one or more clusters exist.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <methodname>getid</methodname> with containment path
                        <literal>/EventInfrastructureProvider:/</literal> will return a list that contains
                        <classname>EventInfrastructureProvider</classname> objects in cluster scope.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <methodname>list</methodname> will also return
                        <classname>EventInfrastructureProvider</classname> objects in cluster scope.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The reason for these discrepancies is as follows. In the first case, the config service would have to
                navigate from the <classname>ServerCluster</classname> object to a child object of type
                <classname>EventInfrastructureProvider</classname>. However, according to the repository metadata,
                such a parent-child relation doesn't exist; according to that metadata, a
                <classname>EventInfrastructureProvider</classname> object can only exist as a child of
                a <classname>Cell</classname>, <classname>Node</classname> or <classname>Server</classname> object.
                Therefore, the <classname>EventInfrastructureProvider</classname> object is not found.
            </para>
            <para>
                In the other cases, the config service performs a subtree search using the optimized
                algorithm described in <xref linkend="adminconfig-list"/>. From the metadata it knows that
                <classname>EventInfrastructureProvider</classname> objects are stored in documents named
                <filename>resources-cei.xml</filename> and it will recursively search for documents with that name.
                This search will return <filename>resources-cei.xml</filename> documents stored in repository
                contexts of type <literal>clusters</literal>, even if according to the metadata they should not exist.
                That is why in these cases, the config service is able to locate the corresponding
                <classname>EventInfrastructureProvider</classname> objects.
            </para>
        </section>
    </section>
    <section>
        <title>Configuration objects and WebSphere variables</title>
        <para>
            The product documentation defines WebSphere variables as follows:
        </para>
        <blockquote>
            <para>
                WebSphere variables are name and value pairs that are used to provide settings
                for any of the string data type attributes that are used to configure the product.
            </para>
        </blockquote>
        <para>
            This implies that WebSphere variables can be used in any attribute of type string of any
            configuration object. As a matter of fact, variable substitution occurs before the
            config service returns the value of an attribute and is therefore supported everywhere
            in the configuration. This can be seen in <xref linkend="fig-variable-expansion"/>.
        </para>
        <figure id="fig-variable-expansion">
            <title>WebSphere variable expansion</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="configobject-getstring.png" format="PNG"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            In this case, the <classname>EndPointMgr</classname> component looks up the value of the
            <literal>host</literal> attribute of a configuration object. That results in a call to
            the <classname>VariableMap</classname> component to substitute WebSphere variables in that
            attribute value.
        </para>
        <para>
            One important thing to understand is that not all the WebSphere configuration is
            stored in configuration objects managed by the config service.
            Some WebSphere components store configuration data as documents in the repository, but without
            letting the config service manage them as documents containing configuration objects serialized
            using EMF.
        </para>
        <para>
            An example of a WebSphere subsystem that does this is the Virtual Member Manager (VMM). It stores a
            certain number of documents with configuration data in the repository under <filename>cells/*/wim</filename>, but these
            are not XMI documents, and there are no configuration object types corresponding to the contents of
            these documents, i.e. they can't be managed using the config service.
        </para>
        <para>
            WebSphere variable substitution doesn't automatically apply to this type of configuration data.
            It is only supported if the WebSphere component or subsystem takes care of it itself.
            For VMM this is not the case. This explains e.g. why the LDAP host in a federated user repositories configuration
            (which is part of VMM and therefore doesn't use the config service)
            cannot be specified using a WebSphere variable, while for a stand-alone LDAP registry (which uses the config service), this is supported.
        </para>
    </section>
    <appendix>
        <title>Correspondance between MBean operations and scripting methods</title>
        <table>
            <title>Correspondance between <classname>AdminConfig</classname> methods and <classname>ConfigService</classname> operations</title>
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry><classname>AdminConfig</classname> method (<command>wsadmin</command>)</entry>
                        <entry><classname>ConfigService</classname> MBean operation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><methodname>parents</methodname></entry>
                        <entry morerows="1" valign="middle"><methodname>getRelationshipsMetaInfo</methodname></entry>
                    </row>
                    <row>
                        <entry><methodname>contents</methodname></entry>
                    </row>
                    <row>
                        <entry><methodname>list</methodname></entry>
                        <entry><methodname>queryConfigObjects</methodname></entry>
                    </row>
                    <row>
                        <entry><methodname>getid</methodname></entry>
                        <entry><methodname>resolve</methodname></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </appendix>
</article>